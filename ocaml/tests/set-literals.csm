// set literals

// ok, so there is a difference between constant and non-constant literals, but I can
// treat both as non-constant for now. This means that my set literals are equivalent 
// to constraints! I should be able to implement them in the parser!

// NEW - FINITE INT TYPE:
var x as {2,4,6};

// Here's a starting point

var s as 1..4[3]; // <-- TODO: Declare & Assign (infer type + re-think card)
var v as {3, 4};
s  = { 1, 2, v }; // <-- Awesome (note that v must be of the type specified in s, that's fine.)

v = 3 + 1; // <-- constant!
v = 3 + bool2int(true);
// Q: can I use the literal in an operation? e.g.
// s  = { 1 } union { 2, 3 };

// NEXT: declare & assign
//var s as 1..3[3] = { 1, 2, 3 };

// NEXT: need to allow 'int' when used with literal assignment
//var s as int[3] = { 1, 2, 3 };

// it's really important to (optionally) auto-determine the card: (though I may in fact allow sets not to specify this later)
//var s as int[] = { 1, 2, 3 };

// NOTE: that the members of these sets may be EXPRESSIONS, this is fine!
// I can optimise generation when they are CONSTANT values though. (maybe just do int/obj literals for now)

// ALSO: expressions for set cardinality would be awesome (though they would need to be constant)

// --------

// EXTRA, I want to allow declare & assign to infer the type automatically (should always be possible - even for objects!)
// this type inference could occur as a pre-process set like forward declarations do.

//var s = { 1, 2, 3 };    // <- we don't care if it is var int because it's a constant anyway.

////////////////////////////////////////////////////////////////////////////////////////////

var z as { 7, 8, 9 }[2..3];
var q as { 9, 10, 11 }[3]; // constant

var b as bool;
// TODO: v = (z union q).size > 3;
b = 1 in (z union q);

// NEW STUFF:

var k as {1,2,3,4,5,6,7,8,9}[];

// constant:  (DISABLED)
//k = {3};

// var int:
var cost as int;
cost = v + 5;

// this works ONLY when `cost` is constant, (otherwise type is int[] which is illegal):
// NOPE: I've now disabled constants.
// k = {cost};

// set of references (needs counting to determine type of card expression)
class C {
  var x as int;
}
var c as C;
var rs as ref C[];
var cc as int;
cc = rs.size;